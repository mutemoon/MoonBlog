# Javascript 模块化

## 历史

### 文件划分

这是最早的模块化实现，简单来说就是把应用的状态和逻辑放到不同的 JS 文件中，HTML 中通过不同的 script 标签一一引入。

### 命名空间

每个变量都有自己专属的命名空间，我们可以清楚地知道某个变量到底属于哪个模块，同时也避免全局变量命名的问题。

### IIFE（立即执行函数）

每个IIFE即立即执行函数都会创建一个私有的作用域，在私有作用域中的变量外界是无法访问的，只有模块内部的方法才能访问。相比于命名空间的模块化手段，IIFE实现的模块化安全性要更高，对于模块作用域的区分更加彻底。

### CommonJS 规范

CommonJS 是业界最早正式提出的 JavaScript 模块规范，主要用于服务端 Node.js。

**问题**

- 它的模块加载器由 Node.js 提供，依赖了 Node.js 本身的功能实现。如果 CommonJS 模块直接放到浏览器中无法执行。
- CommonJS 约定以同步的方式进行模块加载，这种加载机制放到浏览器端，会带来明显的性能问题。它会产生大量同步的模块请求，浏览器要等待响应返回后才能继续解析模块。即，模块请求会造成浏览器 JS 解析过程的阻塞，导致页面加载速度缓慢。
- CommonJS 的这种加载机制放在服务端是没问题的，一来模块都在本地，不需要进行网络 IO，二来只有服务启动时才会加载模块，而服务通常启动后会一直运行，所以对服务的性能并没有太大的影响。

### AMD 规范

AMD全称为Asynchronous Module Definition，即异步模块定义规范。模块根据这个规范，在浏览器环境中会被异步加载，而不会像 CommonJS 规范进行同步加载，也就不会产生同步请求导致的浏览器解析过程阻塞的问题了。

**使用**

```js
// main.js
define(["./print"], function (printModule) {
  printModule.print("main");
});

// print.js
define(function () {
  return {
    print: function (msg) {
      console.log("print " + msg);
    },
  };
});
```

在 AMD 规范当中，我们可以通过 define 去定义或加载一个模块，比如上面的main模块和print模块，如果模块需要导出一些成员需要通过在定义模块的函数中 return 出去(参考print模块)，如果当前模块依赖了一些其它的模块则可以通过 define 的第一个参数来声明依赖(参考main模块)，这样模块的代码执行之前浏览器会先加载依赖模块。

在 AMD 规范当中，我们可以通过 define 去定义或加载一个模块，比如上面的main模块和print模块，如果模块需要导出一些成员需要通过在定义模块的函数中 return 出去(参考print模块)，如果当前模块依赖了一些其它的模块则可以通过 define 的第一个参数来声明依赖(参考main模块)，这样模块的代码执行之前浏览器会先加载依赖模块。

可以使用 require 关键字来加载一个模块，如：

```js

// module-a.js
require(["./print.js"], function (printModule) {
  printModule.print("module-a");
});

```

不过 require 与 define 的区别在于前者只能加载模块，不能定义一个模块。

由于没有得到浏览器的原生支持，AMD 规范仍然需要由第三方的 loader 来实现。不过 AMD 规范使用起来稍显复杂，代码阅读和书写都比较困难。因此，关于新的模块化规范的探索，业界从仍未停止脚步。

### ES Module

ES Module(或ESM)， 是由 ECMAScript 官方提出的模块化规范，它已经得到了现代浏览器的内置支持。

在现代浏览器中，如果在 HTML 中加入含有type="module"属性的 script 标签，那么浏览器会按照 ES Module 规范来进行依赖加载和模块解析，这也是 Vite 在开发阶段实现 no-bundle 的原因。

由于模块加载的任务交给了浏览器，即使不打包也可以顺利运行模块代码，具体的模块加载流程我们会在下一节进行详细的解释。

不仅在浏览器端，一直以 CommonJS 作为模块标准的 Node.js 也从12.20版本开始正式支持原生 ES Module。